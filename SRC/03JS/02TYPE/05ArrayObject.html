<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // // 배열 : 여러 자료 type을 저장하기 위한 자료구조
      // let arr = [
      //   "str1",
      //   "str2",
      //   null,
      //   true,
      //   false,
      //   undefined,
      //   { name: "홍길동", age: 15 },
      // ];

      // //   배열의 type 확인
      // console.log(typeof arr);
      // console.log(arr[0]);
      // console.log(typeof arr[0]);
      // console.log(typeof arr[1]);
      // console.log(typeof arr[2]);
      // console.log(typeof arr[3]);
      // console.log(typeof arr[4]);
      // console.log(typeof arr[5]);
      // console.log(typeof arr[6]);

      // // 배열의 동적 확장 확인
      // // javascript의 배열은 동적 확장이 가능하다. (자바의 리스트와 유사)
      // arr[7] = 100;
      // console.log(arr);
      // arr[10] = "helloworld";
      // console.log(arr);
      // console.log(arr[8], arr[9], arr[10]);
      // console.log("길이 : ", arr.length);

      // // 배열 함수 사용해보기(forEach : 콜백함수)

      // arr.forEach((item) => {
      //   /* item은 개발자가 직접 정한 이름이다. */
      //   console.log("item : ", item);
      // });

      // //   배열 함수 사용해보기
      // // (push - 마지막 index에 요소 추가 )
      // // (pop - 마지막 index 요소 제거)
      // //  push, pop 은 주로 스텍 자료구조에서 사용된다.

      // arr.push("aaaa");
      // arr.push("bbbb");
      // console.log(arr);
      // console.log(arr.pop());
      // console.log(arr.pop());

      //   정렬(sort), 누적(reduce), 필터(filter), 재구성(map)

      // --------------정렬--------------- //

      // let array2 = [
      //   10,
      //   { key1: "v1" },
      //   25,
      //   { key2: "v2" },
      //   87,
      //   undefined,
      //   4,
      //   null,
      //   7,
      //   "15",
      //   38,
      //   8,
      // ];
      // array2.sort(); // 배열의 요소들이 문자열로 변환되어 사전편찬순서로 정렬, 기본값은 오름차순
      // // object와 null은 순서에따라 정렬
      // // array2.forEach((item) => {
      // //   console.log(item);
      // // });
      // // console.log(array2);

      // // array2.sort(() => {}); 콜백함수 형태

      // // 약식표현
      // array2.sort((a, b) => {
      //   return b - a;
      // }); // 내림차순 정렬
      // array2.forEach((item) => console.log("item : ", item));

      // const func1 = () => {}; //사용자 함수
      // func1(); //사용자 함수 호출

      // --------------필터--------------- //

      // filter() 함수는
      // 배열의 요소를 순회하면서 콜백 함수를 사용하여 원하는 조건에 따라 필터링하는 함수입니다.
      // 필터링된 배열을 반환합니다.

      // let arr3 = [
      //   10,
      //   5,
      //   88,
      //   48,
      //   33,
      //   47,
      //   56,
      //   98,
      //   12,
      //   "1",
      //   "47",
      //   { name: "KIM" },
      //   99,
      //   "77",
      //   { age: 25 },
      // ];

      // let filtered_arr1 = arr3.filter((item) => {
      //   return typeof item == "number";
      // });
      // // console.log(filtered_arr1);

      // arr3
      //   .filter((item) => {
      //     return typeof item == "string";
      //   })
      //   .forEach((item) => console.log(item));

      // --------------누적 배열 --------------- //

      // .reduce((누산변수, item)=>{return 연산로직}, 누산변수의 초기값)

      // let arr4 = [
      //   10,
      //   5,
      //   88,
      //   48,
      //   33,
      //   47,
      //   56,
      //   98,
      //   12,
      //   "1",
      //   "47",
      //   { name: "KIM" },
      //   99,
      //   "77",
      //   { age: 25 },
      // ];
      // const result = arr4
      //   .filter((item) => {
      //     return typeof item == "number";
      //   })
      //   .reduce((sum, item) => {
      //     return sum + item;
      //   }, 0);

      // console.log(result);

      // --------------배열 object 처리 [{},{},{}] --------------- //

      // let arr5 = [
      //   { pid: "1", pname: "모니터", price: 150, amount: 50 },
      //   { pid: "2", pname: "노트북", price: 50, amount: 70 },
      //   { pid: "3", pname: "TV", price: 180, amount: 3 },
      //   { pid: "4", pname: "휴대폰", price: 50, amount: 200 },
      //   { pid: "5", pname: "가습기", price: 200, amount: 27 },
      // ];

      // arr5.forEach((item) => {
      //   console.log(item);
      // });
      // console.log("------------------------------");
      // arr5.forEach((item, index) => {
      //   console.log("index :", index, "item : ", item.pname);
      //   // console.log("index :", index, "item : ", item["pname"]);
      // });

      // 각 item의 가격이 100만원 이상인 object만 필터링

      // arr5
      //   .filter((item) => {
      //     return item.price >= 100;
      //   })
      //   .forEach((item) => {
      //     console.log(item);
      //   });

      // const price_sum = arr5
      //   .filter((item) => {
      //     return item.price >= 100;
      //   })
      //   .reduce((sum, item) => {
      //     return sum + item.price; // return sum + item.price; 여기서 item.price에 price 잊어버리지 않기!
      //   }, 0);

      // console.log("가격이 100만원 이상인 item의 가격총합 : ", price_sum);
      // // 각 item의 수량이 30개 이하인 object만 필터링
      // console.log("------------------------------------------------");
      // const result = arr5.filter((item) => {
      //   return item.amount <= 30;
      // });
      // console.log(result);

      // -------------- 재구성 배열 --------------- //
      //  .map((item)=>{return 재구성할 item});

      // let arr6 = [
      //   { pid: "1", pname: "모니터", price: 150, amount: 70 },
      //   { pid: "2", pname: "노트북", price: 80, amount: 50 },
      //   { pid: "3", pname: "TV", price: 180, amount: 3 },
      //   { pid: "4", pname: "휴대폰", price: 50, amount: 200 },
      //   { pid: "5", pname: "가습기", price: 200, amount: 27 },
      // ];

      // // 수량이 50이상이 요소만 필터링해서 price가 낮은 값 우선 오름차순 한 다음 요소마다 price*amount 항목을 추가
      // let result3 = arr6
      //   .filter((item) => {
      //     return item.amount >= 50;
      //   })
      //   .sort((a, b) => {
      //     return a.price - b.price;
      //   })
      //   .map((item) => {
      //     console.log("in item : ", item);
      //     item = { ...item, total_price: item.price * item.amount };
      //     return item;
      //   });

      // console.log(result3);

      //----------------------------------
      //  문제
      //----------------------------------
      let employees = [
        {
          id: 1,
          name: "김철수",
          age: 35,
          department: "개발",
          salary: 6000,
          years: 10,
        },
        {
          id: 2,
          name: "이영희",
          age: 28,
          department: "디자인",
          salary: 5000,
          years: 5,
        },
        {
          id: 3,
          name: "박지성",
          age: 40,
          department: "마케팅",
          salary: 7000,
          years: 15,
        },
        {
          id: 4,
          name: "손흥민",
          age: 30,
          department: "개발",
          salary: 6500,
          years: 7,
        },
        {
          id: 5,
          name: "정우성",
          age: 45,
          department: "경영",
          salary: 9000,
          years: 20,
        },
        {
          id: 6,
          name: "한지민",
          age: 29,
          department: "디자인",
          salary: 5200,
          years: 6,
        },
        {
          id: 7,
          name: "강호동",
          age: 50,
          department: "경영",
          salary: 8500,
          years: 25,
        },
        {
          id: 8,
          name: "유재석",
          age: 42,
          department: "마케팅",
          salary: 7500,
          years: 18,
        },
        {
          id: 9,
          name: "송중기",
          age: 32,
          department: "개발",
          salary: 6200,
          years: 8,
        },
        {
          id: 10,
          name: "수지",
          age: 26,
          department: "디자인",
          salary: 4800,
          years: 3,
        },
      ];

      //연봉이(salary) 6000이상이면서 근속연수(years)가 7년이상인 직원만 필터링해서 배열로 저장 확인
      const result1 = employees.filter((item) => {
        return item.salary >= 6000 && item.years >= 7;
      });
      console.log(result1);
      //모든 직원의 연봉(salary) 기준으로 내림차순 정렬한 배열 새로 만들기
      console.log(
        "--------------------------------------------------------------"
      );
      const result2 = employees
        .sort((a, b) => {
          return b.salary - a.salary;
        })
        .filter((item) => {
          return item;
        });
      console.log(result2);
      //모든 직원의 연봉(salary) 에 근속연수*100 만큼의 보너스를 추가하여 total_salary필드를 추가한 배열을 반환
      console.log(
        "--------------------------------------------------------------"
      );
      const result3 = employees.map((item) => {
        return { ...item, total_salary: item.salary + item.years * 100 };
      });
      console.log(result3);
      //department(부서) 별로 직원들의 연봉총합을 구하세요
      console.log("---------------------------------------------------");
      const result8 = employees.reduce((sum, item) => {
        sum[item.department] =
          (sum[item.department] == undefined ? 0 : sum[item.department]) + // sum[item.department] 은 6000 이다. sum에 키 값을 넣어주면 value 값이 나온다.
          item.salary;
        return sum;
      }, {});

      // {개발 : 12500, 디자인 : 10200, 마케팅 : 7000, 경영 : 17000};
      console.log(result8);

      console.log(
        "--------------------------------------------------------------"
      );
      const result4 = employees
        .filter((item) => {
          return item.department == "개발";
        })
        .reduce((sum, item) => {
          return sum + item.salary;
        }, 0);

      console.log("개발 부서 총 연봉 ", result4);
      const result5 = employees
        .filter((item) => {
          return item.department == "마케팅";
        })
        .reduce((sum, item) => {
          return sum + item.salary;
        }, 0);

      console.log("마케팅 부서 총 연봉 ", result5);

      const result6 = employees
        .filter((item) => {
          return item.department == "디자인";
        })
        .reduce((sum, item) => {
          return sum + item.salary;
        }, 0);

      console.log("디자인 부서 총 연봉 ", result6);

      const result7 = employees
        .filter((item) => {
          return item.department == "경영";
        })
        .reduce((sum, item) => {
          return sum + item.salary;
        }, 0);

      console.log("경영 부서 총 연봉 ", result7);
      //연봉(salary)가 가장높은 직원을 찾아 객체하나만 반환(문서에서 find를 찾아보세요 - !)

      console.log("--------------------------------------------------");
      const result9 = employees.sort((a, b) => {
        return b.salary - a.salary;
      })[0];
      console.log(result9);

      console.log("--------------------------------------------------");

      const result10 = employees.reduce((max, item) => {
        max < item.salary ? item.salary : max;
      });
    </script>
  </body>
</html>
